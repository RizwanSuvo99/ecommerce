name: Deploy to Production

on:
  push:
    tags:
      - 'v*.*.*'

concurrency:
  group: production-deploy
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF_NAME#v}
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION}"

      - name: Verify tag is on main branch
        run: |
          git fetch origin main
          if ! git merge-base --is-ancestor ${{ github.sha }} origin/main; then
            echo "Error: Release tag must be on the main branch"
            exit 1
          fi

  build-and-push:
    name: Build & Push Production Images
    runs-on: ubuntu-latest
    needs: validate
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/api/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/api:${{ needs.validate.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/api:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            APP_VERSION=${{ needs.validate.outputs.version }}

      - name: Build and push Web image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/web/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/web:${{ needs.validate.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/web:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            NEXT_PUBLIC_API_URL=${{ vars.PRODUCTION_API_URL }}
            APP_VERSION=${{ needs.validate.outputs.version }}

  backup:
    name: Pre-deployment Database Backup
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    steps:
      - name: Create database backup
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            cd /opt/ecommerce
            ./scripts/backup-db.sh --dir ./backups/pre-deploy
            echo "Pre-deployment backup completed"

  deploy:
    name: Zero-Downtime Production Deploy
    runs-on: ubuntu-latest
    needs: [validate, build-and-push, backup]
    environment:
      name: production
      url: ${{ vars.PRODUCTION_URL }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy with zero downtime
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            set -euo pipefail
            cd /opt/ecommerce
            
            VERSION=${{ needs.validate.outputs.version }}
            echo "Deploying version ${VERSION}..."
            
            # Save current version for potential rollback
            CURRENT_VERSION=$(docker inspect --format='{{index .Config.Labels "org.opencontainers.image.version"}}' ecommerce-api 2>/dev/null || echo "unknown")
            echo "${CURRENT_VERSION}" > .previous-version
            
            # Pull new images
            docker compose -f docker-compose.prod.yml pull
            
            # Run database migrations
            docker compose -f docker-compose.prod.yml run --rm api npx prisma migrate deploy
            
            # Zero-downtime deployment: scale up new, then remove old
            docker compose -f docker-compose.prod.yml up -d --remove-orphans --force-recreate
            
            # Wait for health checks to pass
            echo "Waiting for services to become healthy..."
            MAX_RETRIES=30
            RETRY_COUNT=0
            until [ $RETRY_COUNT -ge $MAX_RETRIES ]; do
              if curl -sf http://localhost:4000/api/health > /dev/null 2>&1; then
                echo "API is healthy!"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Waiting for API to become healthy... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 5
            done
            
            if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
              echo "Health check failed after ${MAX_RETRIES} retries. Initiating rollback..."
              exit 1
            fi
            
            # Cleanup old images
            docker image prune -f
            
            echo "Version ${VERSION} deployed successfully!"

      - name: Verify deployment
        run: |
          sleep 10
          response=$(curl -s ${{ vars.PRODUCTION_API_URL }}/api/health)
          echo "Health check response: $response"
          status=$(echo $response | jq -r '.status')
          if [ "$status" != "ok" ]; then
            echo "Production health check failed!"
            exit 1
          fi
          echo "Production deployment verified successfully!"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    environment: production
    steps:
      - name: Execute rollback
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            cd /opt/ecommerce
            
            PREVIOUS_VERSION=$(cat .previous-version 2>/dev/null || echo "")
            if [ -z "$PREVIOUS_VERSION" ] || [ "$PREVIOUS_VERSION" = "unknown" ]; then
              echo "No previous version found for rollback!"
              exit 1
            fi
            
            echo "Rolling back to version ${PREVIOUS_VERSION}..."
            
            # Restore database from pre-deploy backup
            LATEST_BACKUP=$(ls -t ./backups/pre-deploy/backup_*.dump.gz 2>/dev/null | head -1)
            if [ -n "$LATEST_BACKUP" ]; then
              echo "Restoring database from: ${LATEST_BACKUP}"
              ./scripts/restore-db.sh "${LATEST_BACKUP}" --yes
            fi
            
            # Roll back to previous image versions
            export API_IMAGE_TAG="${PREVIOUS_VERSION}"
            export WEB_IMAGE_TAG="${PREVIOUS_VERSION}"
            docker compose -f docker-compose.prod.yml up -d --force-recreate
            
            echo "Rollback to version ${PREVIOUS_VERSION} completed"

      - name: Notify rollback
        if: always()
        run: echo "ALERT - Production rollback was triggered! Manual verification required."

  release-notes:
    name: Create Release Notes
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        uses: softprops/action-gh-release@v1
        with:
          generate_release_notes: true
          tag_name: ${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
